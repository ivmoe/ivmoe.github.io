<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LUKS加密磁盘</title>
      <link href="/posts/23942/"/>
      <url>/posts/23942/</url>
      
        <content type="html"><![CDATA[<blockquote><p>软件包 cryptsetup</p></blockquote><h2 id="加密分区"><a href="#加密分区" class="headerlink" title="加密分区"></a>加密分区</h2><p>创建分区后，加密分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cryptsetup luksFormat [Device]/dev/sda2</span><br><span class="line"></span><br><span class="line">例：cryptsetup luksFormat /dev/sda2</span><br></pre></td></tr></table></figure><p>输入大写的“YES”，回车</p><p>输入两次密码，密码复杂度有要求</p><h2 id="打开加密分区"><a href="#打开加密分区" class="headerlink" title="打开加密分区"></a>打开加密分区</h2><p>输入命令，并创建加密分区的别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cryptsetup luksOpen [Device] [Name]</span><br><span class="line"></span><br><span class="line">[Name]是指加密后的分区名称，在/dev/mapper中体现</span><br><span class="line"></span><br><span class="line">例：cryptsetup luksOpen /dev/sda2 cr_data</span><br></pre></td></tr></table></figure><h2 id="挂载加密分区"><a href="#挂载加密分区" class="headerlink" title="挂载加密分区"></a>挂载加密分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/mapper/[Name]</span><br><span class="line"></span><br><span class="line">例：mkfs.ext4 /dev/mapper/cr_data</span><br><span class="line"></span><br><span class="line">mount /dev/mapper/cr_data /data</span><br></pre></td></tr></table></figure><h2 id="自动解密挂载"><a href="#自动解密挂载" class="headerlink" title="自动解密挂载"></a>自动解密挂载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加解密文件</span></span><br><span class="line">cryptsetup luksAddKey /dev/sda2 /root/cryptpasswd</span><br><span class="line"><span class="comment">#/root/cryptpasswd 文件中写入新的密码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Minda00$&quot;</span> | cryptsetup luksAddKey /dev/sda2 /root/cryptpasswd</span><br><span class="line"></span><br><span class="line">vim /etc/crypttab</span><br><span class="line">写入内容：</span><br><span class="line">  cr_data  /dev/sda2  /root/cryptpasswd</span><br><span class="line">建议 /root/cryptpasswd 使用随机数</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">spasswd=$(openssl rand -<span class="built_in">base64</span> 10)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$spasswd</span> &gt; /root/cryptpasswd</span><br><span class="line"></span><br><span class="line">vim /etc/fstab</span><br><span class="line">写入内容：</span><br><span class="line">cr_data  /data  ext4  defaults  0  0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> LUKS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>愿你历尽千帆，归来仍少年</title>
      <link href="/posts/30155/"/>
      <url>/posts/30155/</url>
      
        <content type="html"><![CDATA[<h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>传说中有一位少年，听闻东方有屠龙之术，便下定决心前往学习。</p><p>他不惜翻山越岭披荆斩棘，一去就是十年，回来的时候一身狼狈，村民都笑他：“世上本无龙之术，何谈屠龙，简直荒谬！”</p><p>昔日的少年早已过了而立之年，尚无妻室，低下头不知所言，封了剑下田耕作，不再提及十年往事。</p><p>过了三年，村子附近的湖底有一蛟龙作恶，许多担水的壮汉和洗衣的农妇，都喂了它的肚子。</p><p>少年脱掉斗笠蓑衣，依旧不言不语，拔剑独斗蛟龙，日夜苦战。第六日西边残霞如血，少年取蛟龙首级而归。</p><p>我们都以为少年难抵峥嵘岁月惆，不曾想他的热血未凉，只是只字不提过往。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>《小王子》里写：所有成年人都曾经是一个孩子，但很少有人能记得这一点了。</p><p>曾经的少年，疯了一样骑着自行车在雨里狂奔，绕道几公里只为和一个姑娘偶遇。</p><p>他拿起扫把，就是插了电的吉他，收起雨伞，就是开过锋的宝剑。有时走在路上，一扭头，扑面的狂风灌满了衣服。</p><p>尘土飞扬，旌旗猎猎，两军对峙，黑压压的一片看不到边。他是阵前的将军，白马银袍，手握方天画戟，一个人冲锋陷阵。</p><p>当然，也有这种可能，他空有一腔热血却无处投身，不够优秀也不够完美，甚至充满了顽劣的孩子气。</p><p>他在球场上疯跑忘记了回家，做事不怎么考虑意义和对错，和好哥们儿打一架很快又和好如初，痴迷一本没营养的小说幻想拯救世界。</p><p>他做了不对的事情会倔强地辩解，做了不好的事情会泯着嘴脸红，哪怕姑娘主动拉他的手还会躲开，不会顺水推舟只会迫不得已。</p><p>他说，昨天夜里这个世界让我哭泣和怨恨，但今天清晨醒来的时候，我仍然热爱这个世界。</p><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p>后来，少年落寞地穿行在城市的钢筋混凝土中，怀疑自己存在的价值，怀念少年时节。</p><p>他偶然路过超市橱窗，凝望着小时候朝思暮想的铁甲小宝。他有着驰骋文学的梦想，每晚下班关掉手机，埋头苦读经典名著。他想娶那么优秀的她，不断突破现实的绝境，使出拼命抵抗的力量。</p><p>他在办公座椅一转，漂亮的弧线投纸正中垃圾桶。天台吹风干吼一声，庆幸自己没有变成凶煞的狼人。拥挤的公交，碰到头发灰白的老太，娴熟地站立、转身，说一句：您老坐。</p><p>谁不是活着活着就悄然活成另一个人，青春梦醒，爱情梦断，只有不可说，只有不必说。</p><p>“男人”作为概念，给人的感觉，除了象征宽厚的肩膀，还隐隐带有父权的威仪，或许让人敬畏，但难生亲近。</p><p>而“少年”，他的身躯尚单薄，自顾不暇，但有一份热切和孤勇在，他的追求、叩问、承担、迷茫、与反抗，都带着让人怜爱的真实与诚恳。</p><p>少年，是面对生活的琐碎，怀着本真的好奇，是面对世事的艰难，抱着坚定的信念。少年，是面对浩瀚的星空，留着探索的欲望，是面对深邃的知识，有着追寻的渴求。</p><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><p>曾经看到一条微博，看到的时候，竟然湿了眼眶。</p><p>“尚未佩妥剑，转眼便江湖。愿历尽千帆，归来仍少年。”</p><p>十年前，我们的心脏很厚，用力才能碎，里面是信纸、红袖章、发条青蛙、鸡毛毽子和崭新的回力运动鞋。十年后我们的心脏很薄，一吹就会破，里面是路灯、啤酒瓶、失眠夜、黑眼圈和忘关的电脑。</p><p>也许，这个世界真的没有所谓的屠龙之术，传说中的少年，有的只是一把锈迹斑斑的铁剑，但在所有人都仓皇出逃时，他有提剑而上的勇气。</p><p>我们也曾是少年，会老会胖会掉节操，见过他人行絜冰霜的凛然，温柔地和这个世界对抗。我们的身影颀长而挺拔，神情淡漠而倔强。</p><p>虽千万人吾往矣，永远年轻，永远热泪盈眶。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 励志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化安装Ubuntu20.04</title>
      <link href="/posts/3875/"/>
      <url>/posts/3875/</url>
      
        <content type="html"><![CDATA[<h1 id="自动化安装Ubuntu20-04"><a href="#自动化安装Ubuntu20-04" class="headerlink" title="自动化安装Ubuntu20.04"></a>自动化安装Ubuntu20.04</h1><div class="note danger simple"><p>只能使用 live server 版！！！</p></div><p>下载想要版本的 iso 文件备用，可在<a target="_blank" rel="noopener" href="https://old-releases.ubuntu.com/releases/">这里</a>下载到历史版本。</p><p>准备一个安装好的操作系统 Ubuntu20.04，将刚刚下载的 iso 文件放到操作系统中。</p><p>使用工具一键制作，在 GitHub 下载 <a target="_blank" rel="noopener" href="https://github.com/covertsh/ubuntu-autoinstall-generator">ubuntu-autoinstall-generator</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要先修改下这个脚本中的验证，不然不会通过老版本的，只会有最新版本的</span></span><br><span class="line"></span><br><span class="line">bash ubuntu-autoinstall-generator.sh -a -u user-data.example -s 官方iso文件 -d ubuntu-autoinstall.iso</span><br></pre></td></tr></table></figure><p>user-data 这个文件怎么配置可以在 ubuntu <a target="_blank" rel="noopener" href="https://ubuntu.com/server/docs/install/autoinstall-reference">官方文档</a>中查看。</p><p>密码加密的命令 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;密码&#x27;</span> | openssl passwd -6 -salt <span class="string">&#x27;FhcddHFVZ7ABA4Gi加密代码&#x27;</span> -stdin</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span>   /mysoft</span><br><span class="line"><span class="built_in">cp</span> -rf /var/cache/apt/archives /mysoft</span><br><span class="line"><span class="built_in">chmod</span> -R 777 /mysoft</span><br><span class="line"><span class="built_in">cd</span> /mysoft</span><br><span class="line">apt-ftparchive packages archives &gt;archives/Packages</span><br><span class="line"><span class="built_in">cd</span> archives/</span><br><span class="line">gzip -c Packages &gt; Packages.gz</span><br><span class="line"><span class="built_in">touch</span> release</span><br><span class="line">apt-ftparchive release ./ &gt;Release</span><br><span class="line">修改配置文件</span><br><span class="line">root@pc01:~<span class="comment"># cp sources.list&#123;,.bak&#125;</span></span><br><span class="line">root@pc01:~<span class="comment"># vim /etc/apt/sources.list</span></span><br><span class="line">deb [trusted=<span class="built_in">yes</span>] file:/mysoft archives/ </span><br><span class="line">root@pc01:~<span class="comment"># apt-get update</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################说明##################################</span></span><br><span class="line">后期再有包加入的时候，在执行一遍这几步就行了</span><br><span class="line">apt-ftparchive packages archives &gt;archives/Packages</span><br><span class="line">gzip -c Packages &gt; Packages.gz</span><br><span class="line">apt-ftparchive release ./ &gt;Release</span><br><span class="line"><span class="comment">###########################################################</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过KVM制作OpenStack镜像</title>
      <link href="/posts/19535/"/>
      <url>/posts/19535/</url>
      
        <content type="html"><![CDATA[<h2 id="在Ubuntu20-04上安装KVM"><a href="#在Ubuntu20-04上安装KVM" class="headerlink" title="在Ubuntu20.04上安装KVM"></a>在Ubuntu20.04上安装KVM</h2><p>运行以下命令以安装KVM和其他虚拟化管理软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager</span><br></pre></td></tr></table></figure><ul><li><code>qemu-kvm</code> -为KVM管理程序提供硬件仿真的软件。</li><li><code>libvirt-daemon-system</code> -用于将libvirt守护程序作为系统服务运行的配置文件。</li><li><code>libvirt-clients</code> -用于管理虚拟化平台的软件。</li><li><code>bridge-utils</code> -一组用于配置以太网桥的命令行工具。</li><li><code>virtinst</code> -一组用于创建虚拟机的命令行工具。</li><li><code>virt-manager</code> -易于使用的GUI界面和支持命令行工具，用于通过libvirt管理虚拟机。</li></ul><p>安装软件包后，libvirt守护程序将自动启动。您可以通过键入以下内容进行验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl is-active libvirtd</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">active</span><br></pre></td></tr></table></figure><p>为了能够创建和管理虚拟机，您需要将用户添加到“ libvirt”和“ kvm”组中。为此，请输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG libvirt <span class="variable">$USER</span></span><br><span class="line">sudo usermod -aG kvm <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p><code>$USER</code> 是一个环境变量，其中包含当前登录用户的名称。</p><p>注销并重新登录，以便刷新组成员身份。</p><h2 id="压缩qcow2镜像文件"><a href="#压缩qcow2镜像文件" class="headerlink" title="压缩qcow2镜像文件"></a>压缩qcow2镜像文件</h2><p>虚拟机需要关机，qcow2的存放位置：<code>/var/lib/libvirt/images/</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#复制镜像文件到其他目录</span></span><br><span class="line">sudo <span class="built_in">cp</span> /var/lib/libvirt/images/tes.qcow2 /data/test.qcow2</span><br><span class="line"></span><br><span class="line"><span class="comment">#导出压缩后的镜像文件</span></span><br><span class="line">sudo qemu-img convert -c -O qcow2 test.qcow2 new.qcow2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
            <tag> OpenStack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积神经网络-CNN</title>
      <link href="/posts/37296/"/>
      <url>/posts/37296/</url>
      
        <content type="html"><![CDATA[<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-24-cnn.png" alt="一文看懂卷积神经网络-CNN"></p><blockquote><p>卷积神经网络 - CNN 最擅长的就是图片的处理。它受到人类视觉神经系统的启发。</p><p>CNN 有2大特点：</p><ol><li>能够有效的将大数据量的图片降维成小数据量</li><li>能够有效的保留图片特征，符合图片处理的原则</li></ol><p>目前 CNN 已经得到了广泛的应用，比如：人脸识别、自动驾驶、美图秀秀、安防等很多领域。</p></blockquote><h2 id="CNN-解决了什么问题？"><a href="#CNN-解决了什么问题？" class="headerlink" title="CNN 解决了什么问题？"></a>CNN 解决了什么问题？</h2><p>在 CNN 出现之前，图像对于人工智能来说是一个难题，有2个原因：</p><ol><li>图像需要处理的数据量太大，导致成本很高，效率很低</li><li>图像在数字化的过程中很难保留原有的特征，导致图像处理的准确率不高</li></ol><p>下面就详细说明一下这2个问题：</p><h3 id="需要处理的数据量太大"><a href="#需要处理的数据量太大" class="headerlink" title="需要处理的数据量太大"></a>需要处理的数据量太大</h3><p>图像是由像素构成的，每个像素又是由颜色构成的。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-12-xiangsu.png" alt="图像是由像素构成的，每个像素又是由颜色构成的"></p><p>现在随随便便一张图片都是 1000×1000 像素以上的， 每个像素都有RGB 3个参数来表示颜色信息。</p><p>假如我们处理一张 1000×1000 像素的图片，我们就需要处理3百万个参数！</p><p>1000×1000×3&#x3D;3,000,000</p><p>这么大量的数据处理起来是非常消耗资源的，而且这只是一张不算太大的图片！</p><p><strong>卷积神经网络 - CNN 解决的第一个问题就是「将复杂问题简化」，把大量参数降维成少量参数，再做处理。</strong></p><p><strong>更重要的是：我们在大部分场景下，降维并不会影响结果。比如1000像素的图片缩小成200像素，并不影响肉眼认出来图片中是一只猫还是一只狗，机器也是如此。</strong></p><h3 id="保留图像特征"><a href="#保留图像特征" class="headerlink" title="保留图像特征"></a>保留图像特征</h3><p>图片数字化的传统方式我们简化一下，就类似下图的过程：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-12-tuxiangtx.png" alt="图像简单数字化无法保留图像特征"></p><p>假如有圆形是1，没有圆形是0，那么圆形的位置不同就会产生完全不同的数据表达。但是从视觉的角度来看，<br><strong>图像的内容（本质）并没有发生变化，只是位置发生了变化</strong> 。</p><p>所以当我们移动图像中的物体，用传统的方式的得出来的参数会差异很大！这是不符合图像处理的要求的。</p><p><strong>而 CNN 解决了这个问题，他用类似视觉的方式保留了图像的特征，当图像做翻转，旋转或者变换位置时，它也能有效的识别出来是类似的图像。</strong></p><p>那么卷积神经网络是如何实现的呢？在我们了解 CNN 原理之前，先来看看人类的视觉原理是什么？</p><h2 id="人类的视觉原理"><a href="#人类的视觉原理" class="headerlink" title="人类的视觉原理"></a>人类的视觉原理</h2><p>深度学习的许多研究成果，离不开对大脑认知原理的研究，尤其是视觉原理的研究。</p><p>1981 年的诺贝尔医学奖，颁发给了 David Hubel（出生于加拿大的美国神经生物学家） 和TorstenWiesel，以及 Roger<br>Sperry。前两位的主要贡献，是“ <strong>发现了视觉系统的信息处理</strong> ”，可视皮层是分级的。</p><p>人类的视觉原理如下：从原始信号摄入开始（瞳孔摄入像素<br>Pixels），接着做初步处理（大脑皮层某些细胞发现边缘和方向），然后抽象（大脑判定，眼前的物体的形状，是圆形的），然后进一步抽象（大脑进一步判定该物体是只气球）。下面是人脑进行人脸识别的一个示例：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-24-rennao.png" alt="人类视觉原理1"></p><p>对于不同的物体，人类视觉也是通过这样逐层分级，来进行认知的：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-19-renlei-shijue2.jpg" alt="人类视觉原理2"></p><p>我们可以看到，在最底层特征基本上是类似的，就是各种边缘，越往上，越能提取出此类物体的一些特征（轮子、眼睛、躯干等），到最上层，不同的高级特征最终组合成相应的图像，从而能够让人类准确的区分不同的物体。</p><p>那么我们可以很自然的想到：可以不可以模仿人类大脑的这个特点，构造多层的神经网络，较低层的识别初级的图像特征，若干底层特征组成更上一层特征，最终通过多个层级的组合，最终在顶层做出分类呢？</p><p><strong>答案是肯定的，这也是许多深度学习算法（包括CNN）的灵感来源。</strong></p><h2 id="卷积神经网络-CNN-的基本原理"><a href="#卷积神经网络-CNN-的基本原理" class="headerlink" title="卷积神经网络-CNN 的基本原理"></a>卷积神经网络-CNN 的基本原理</h2><p>典型的 CNN 由3个部分构成：</p><ol><li>卷积层</li><li>池化层</li><li>全连接层</li></ol><p>如果简单来描述的话：</p><p>卷积层负责提取图像中的局部特征；池化层用来大幅降低参数量级(降维)；全连接层类似传统神经网络的部分，用来输出想要的结果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-24-cnnjiegou.png" alt="典型的CNN 由3个部分构成"></p><p>下面的原理解释为了通俗易懂，忽略了很多技术细节，如果大家对详细的原理感兴趣，可以看这个视频《<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ns411g75X?p=3">卷积神经网络基础</a>》。</p><h3 id="卷积——提取特征"><a href="#卷积——提取特征" class="headerlink" title="卷积——提取特征"></a>卷积——提取特征</h3><p>卷积层的运算过程如下图，用一个卷积核扫完整张图片：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-19-juanji.gif" alt="卷积层运算过程"></p><p>这个过程我们可以理解为我们使用一个过滤器（卷积核）来过滤图像的各个小区域，从而得到这些小区域的特征值。</p><p>在具体应用中，往往有多个卷积核，可以认为，每个卷积核代表了一种图像模式，如果某个图像块与此卷积核卷积出的值大，则认为此图像块十分接近于此卷积核。如果我们设计了6个卷积核，可以理解：我们认为这个图像上有6种底层纹理模式，也就是我们用6中基础模式就能描绘出一副图像。以下就是25种不同的卷积核的示例：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-19-150926.jpg" alt="25种不同的卷积核"></p><p><strong>总结：卷积层的通过卷积核的过滤提取出图片中局部的特征，跟上面提到的人类视觉的特征提取类似。</strong></p><h3 id="池化层（下采样）——数据降维，避免过拟合"><a href="#池化层（下采样）——数据降维，避免过拟合" class="headerlink" title="池化层（下采样）——数据降维，避免过拟合"></a>池化层（下采样）——数据降维，避免过拟合</h3><p>池化层简单说就是下采样，他可以大大降低数据的维度。其过程如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-19-chihua.gif" alt="池化层过程"></p><p>上图中，我们可以看到，原始图片是20×20的，我们对其进行下采样，采样窗口为10×10，最终将其下采样成为一个2×2大小的特征图。</p><p>之所以这么做的原因，是因为即使做完了卷积，图像仍然很大（因为卷积核比较小），所以为了降低数据维度，就进行下采样。</p><p><strong>总结：池化层相比卷积层可以更有效的降低数据维度，这么做不但可以大大减少运算量，还可以有效的避免过拟合。</strong></p><h3 id="全连接层——输出结果"><a href="#全连接层——输出结果" class="headerlink" title="全连接层——输出结果"></a>全连接层——输出结果</h3><p>这个部分就是最后一步了，经过卷积层和池化层处理过的数据输入到全连接层，得到最终想要的结果。</p><p>经过卷积层和池化层降维过的数据，全连接层才能”跑得动”，不然数据量太大，计算成本高，效率低下。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-19-quanlianjie.png" alt="全连接层"></p><p>典型的 CNN 并非只是上面提到的3层结构，而是多层结构，例如 LeNet-5 的结构就如下图所示：</p><p><strong>卷积层 - 池化层- 卷积层 - 池化层 - 卷积层 - 全连接层</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-19-lenet.png" alt="LeNet-5网络结构"></p><p>在了解了 CNN 的基本原理后，我们重点说一下 CNN 的实际应用有哪些。</p><h2 id="CNN-有哪些实际应用？"><a href="#CNN-有哪些实际应用？" class="headerlink" title="CNN 有哪些实际应用？"></a>CNN 有哪些实际应用？</h2><p>卷积神经网络 - CNN 很擅长处理图像。而视频是图像的叠加，所以同样擅长处理视频内容。下面给大家列一些比较成熟的应用：</p><p><strong>图像分类、检索</strong></p><p>图像分类是比较基础的应用，他可以节省大量的人工成本，将图像进行有效的分类。对于一些特定领域的图片，分类的准确率可以达到<br>95%+，已经算是一个可用性很高的应用了。</p><p>典型场景：图像搜索…</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-12-cnn-fenlei.png" alt="CNN应用-图像分类、检索"></p><p><strong>目标定位检测</strong></p><p>可以在图像中定位目标，并确定目标的位置及大小。</p><p>典型场景：自动驾驶、安防、医疗…</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-12-cnn-dingwei-1.png" alt="CNN应用-目标"></p><p><strong>目标分割</strong></p><p>简单理解就是一个像素级的分类。</p><p>他可以对前景和背景进行像素级的区分、再高级一点还可以识别出目标并且对目标进行分类。</p><p>典型场景：美图秀秀、视频后期加工、图像生成…</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-12-cnn-fenge-1.png" alt="CNN应用-目标分割"></p><p><strong>人脸识别</strong></p><p>人脸识别已经是一个非常普及的应用了，在很多领域都有广泛的应用。</p><p>典型场景：安防、金融、生活…</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-12-cnn-renlian.png" alt="CNN应用-人脸识别"></p><p><strong>骨骼识别</strong></p><p>骨骼识别是可以识别身体的关键骨骼，以及追踪骨骼的动作。</p><p>典型场景：安防、电影、图像视频生成、游戏…</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://easy-ai.oss-cn-shanghai.aliyuncs.com/2019-06-12-cnn-guge.png" alt="CNN应用-骨骼识别"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们介绍了 CNN 的价值、基本原理和应用场景，简单总结如下：</p><p><strong>CNN 的价值：</strong></p><ol><li>能够将大数据量的图片有效的降维成小数据量(并不影响结果)</li><li>能够保留图片的特征，类似人类的视觉原理</li></ol><p><strong>CNN 的基本原理：</strong></p><ol><li>卷积层 - 主要作用是保留图片的特征</li><li>池化层 - 主要作用是把数据降维，可以有效的避免过拟合</li><li>全连接层 - 根据不同任务输出我们想要的结果</li></ol><p><strong>CNN 的实际应用：</strong></p><ol><li>图片分类、检索</li><li>目标定位检测</li><li>目标分割</li><li>人脸识别</li><li>骨骼识别</li></ol><div class="tabs" id="百度百科"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#百度百科-1">百度百科 1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="百度百科-1"><p>卷积神经网络（Convolutional Neural Networks, CNN）是一类包含卷积计算且具有深度结构的前馈神经网络（Feedforward Neural Networks），是深度学习（deep learning）的代表算法之一 。由于卷积神经网络能够进行平移不变分类（shift-invariant classification），因此也被称为“平移不变人工神经网络（Shift-Invariant Artificial Neural Networks, SIANN）”。</p><p>对卷积神经网络的研究始于二十世纪80至90年代，时间延迟网络和LeNet-5是最早出现的卷积神经网络；在二十一世纪后，随着深度学习理论的提出和数值计算设备的改进，卷积神经网络得到了快速发展，并被大量应用于计算机视觉、自然语言处理等领域。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><a class="btn-beautify blue larger" target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"   title="查看详情"><i class="far fa-hand-point-right"></i><span>查看详情</span></a><p><strong>转载自 <a target="_blank" rel="noopener" href="https://easyai.tech/ai-definition/cnn/">https://easyai.tech/ai-definition/cnn/</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装NFS服务器</title>
      <link href="/posts/13583/"/>
      <url>/posts/13583/</url>
      
        <content type="html"><![CDATA[<blockquote><p>安装Linux系统，这里是CentOS7，操作全程在root下进行，关闭防火墙和SELinux。</p></blockquote><h2 id="添加新的硬盘"><a href="#添加新的硬盘" class="headerlink" title="添加新的硬盘"></a>添加新的硬盘</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l    #查看硬盘状态</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 3298.5 GB, 3298534883328 bytes, 6442450944 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fdisk /dev/sdb    #对磁盘进行操作</span><br><span class="line"></span><br><span class="line">Command (m for help): m# 根据提示添加新的分区</span><br><span class="line">Command action</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create an IRIX (SGI) partition table</span><br><span class="line">   l   list known partition types</span><br><span class="line">   m   print this menu</span><br><span class="line">   n   add a new partition</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   print the partition table</span><br><span class="line">   q   quit without saving changes</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition&#x27;s system id</span><br><span class="line">   u   change display/entry units</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   w   write table to disk and exit</span><br><span class="line">   x   extra functionality (experts only)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">操作完成后按“w”保存退出。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">对分区进行格式化,此处为xfs格式，还有ext4、ext3等</span></span><br><span class="line">mkfs -t xfs /dev/sdb1</span><br></pre></td></tr></table></figure><p>创建将要作为NFS分享的文件夹：<code>mkdir /nfs</code>，更改归属组与用户<code>chown -R root.root /nfs</code></p><p>挂载硬盘：<code>mount /dev/sdb1 /nfs</code></p><p>永久保存挂载点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/fstab</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">填入下面的内容</span></span><br><span class="line">/dev/sdb1       /nfs    xfs    defaults        0 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">保存退出，重启机器</span></span><br></pre></td></tr></table></figure><h2 id="安装NFS服务"><a href="#安装NFS服务" class="headerlink" title="安装NFS服务"></a>安装NFS服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nfs-utils rpcbind</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置开机自启</span></span><br><span class="line">systemctl enable rpcbind</span><br><span class="line">systemctl enable nfs-server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑exports</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi /etc/exports</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入以下内容(格式：NFS共享的目录 NFS客户端地址1(参数1,参数2,...) 客户端地址2(参数1,参数2,...))</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/nfs 192.168.2.0/24(rw,async,no_root_squash)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果设置为 /nfs *(rw,async,no_root_squash) 则对所有的IP都有效</span></span><br></pre></td></tr></table></figure><ul><li>常用选项：<ul><li>ro：客户端挂载后，其权限为只读，默认选项；</li><li>rw:读写权限；</li><li>sync：同时将数据写入到内存与硬盘中；</li><li>async：异步，优先将数据保存到内存，然后再写入硬盘；</li><li>Secure：要求请求源的端口小于1024</li></ul></li><li>用户映射：<ul><li>root_squash:当NFS客户端使用root用户访问时，映射到NFS服务器的匿名用户；</li><li>no_root_squash:当NFS客户端使用root用户访问时，映射到NFS服务器的root用户；</li><li>all_squash:全部用户都映射为服务器端的匿名用户；</li><li>anonuid&#x3D;UID：将客户端登录用户映射为此处指定的用户uid；</li><li>anongid&#x3D;GID：将客户端登录用户映射为此处指定的用户gid</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看nfs服务端信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nfsstat -s</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看nfs客户端信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nfsstat -c</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Enable etcrc.local with systemd on Ubuntu 20.04</title>
      <link href="/posts/30648/"/>
      <url>/posts/30648/</url>
      
        <content type="html"><![CDATA[<div class="note success simple"><p>在Ubuntu20.04上实现可systemd管理的&#x2F;etc&#x2F;rc.local</p></div><blockquote><p>Certain Linux distributions that use <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Systemd">SystemD</a>such as Ubuntu 20.04 may not allow you to run &#x2F;etc&#x2F;rc.local when the system is booting. In this tutorial we will go through how to enable &#x2F;etc&#x2F;rc.local with systemd during system boot on Ubuntu 20.04.</p></blockquote><h3 id="Procedure-to-setup-x2F-etc-x2F-rc-local-with-systemd-on-Ubuntu-20-04"><a href="#Procedure-to-setup-x2F-etc-x2F-rc-local-with-systemd-on-Ubuntu-20-04" class="headerlink" title="Procedure to setup &#x2F;etc&#x2F;rc.local with systemd on Ubuntu 20.04"></a>Procedure to setup &#x2F;etc&#x2F;rc.local with systemd on Ubuntu 20.04</h3><p>Check the current status of rc-local service</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status rc-local</span><br></pre></td></tr></table></figure><h3 id="Enable-rc-local-service"><a href="#Enable-rc-local-service" class="headerlink" title="Enable rc.local service"></a>Enable rc.local service</h3><p>Enable &#x2F;etc&#x2F;rc.local to run on system boot using the command</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable rc-local</span><br></pre></td></tr></table></figure><p>As you may have already read, it is not possible to enable rc.local at startup<br>using SystemD on Ubuntu 20.04. Therefore we have to do this another way.</p><h3 id="Manually-create-a-systemd-service"><a href="#Manually-create-a-systemd-service" class="headerlink" title="Manually create a systemd service"></a>Manually create a systemd service</h3><p>We will need to manually create a SystemD service which will start at system<br>boot.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/systemd/system/rc-local.service</span><br></pre></td></tr></table></figure><p>Now enter the following text, save and close the file.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"> Description=/etc/rc.local Compatibility</span><br><span class="line"> ConditionPathExists=/etc/rc.local</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"> Type=forking</span><br><span class="line"> ExecStart=/etc/rc.local start</span><br><span class="line"> TimeoutSec=0</span><br><span class="line"> StandardOutput=tty</span><br><span class="line"> RemainAfterExit=yes</span><br><span class="line"> SysVStartPriority=99</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"> WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h3 id="Create-and-Edit-rc-local-file"><a href="#Create-and-Edit-rc-local-file" class="headerlink" title="Create and Edit rc.local file"></a>Create and Edit rc.local file</h3><p>Now we will need to edit the &#x2F;etc&#x2F;rc.local file. Issue the following command<br>and press Enter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/rc.local</span><br></pre></td></tr></table></figure><p>Paste in the following, this ensures that the script is bash executable, all<br>bash scripts shoul have this at the top</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br></pre></td></tr></table></figure><p>save and close the file.</p><p>We will now need to append permissions to make the newly created file<br>executable. Issue the following command and press Enter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/rc.local</span><br></pre></td></tr></table></figure><h3 id="Enable-the-service-on-boot"><a href="#Enable-the-service-on-boot" class="headerlink" title="Enable the service on boot"></a>Enable the service on boot</h3><p>enable rc.local with systemd on Ubuntu 20.04</p><p>After that, enable the service on system boot</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable rc-local</span><br></pre></td></tr></table></figure><p>Now let’s reboot the system and check if the rc-local SystemD service is<br>working.</p><p>When your system has booted up again, issue the following command</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status rc-local</span><br></pre></td></tr></table></figure><p>Enabling &#x2F;etc&#x2F;rc.local with systemd is completed on Ubuntu 20.04 startup.</p><p>转载自：<a target="_blank" rel="noopener" href="https://marsown.com/wordpress/how-to-enable-etc-rc-local-with-systemd-on-ubuntu-20-04/">https://marsown.com/wordpress/how-to-enable-etc-rc-local-with-systemd-on-ubuntu-20-04/</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KVM虚拟机启动报错“unable to set AppArmor profile &#39;libvirt-&#39; for &#39;usrbinqemu-system-x86_64&#39; No such file or directory”</title>
      <link href="/posts/1253/"/>
      <url>/posts/1253/</url>
      
        <content type="html"><![CDATA[<p>我的虚拟机稳定的运行了一段时间，由于参加WAIC展会，期间晚上断电关机，所以宿主机需要较为频繁的重启。</p><p>这事在展会的第四天终于出问题了。我一共是5个虚拟机，早上开机，稳稳的起来了三个，但是有两个挺重要的虚机没有起来，报错如下：</p><div class="note danger simple"><p>internal error: Process exited prior to exec: libvirt:  error : unable to set AppArmor profile ‘libvirt-91916cbc-63e6-437c-9932-4ce813b079d2’ for ‘&#x2F;usr&#x2F;bin&#x2F;qemu-system-x86_64’: No such file or directory</p></div><p>解决办法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> /etc/apparmor.d/libvirt/libvirt*</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04安装Nvidia显卡驱动</title>
      <link href="/posts/65062/"/>
      <url>/posts/65062/</url>
      
        <content type="html"><![CDATA[<h1 id="下载显卡驱动"><a href="#下载显卡驱动" class="headerlink" title="下载显卡驱动"></a>下载显卡驱动</h1><p><code>lspci | grep -i nvidia</code> 查看显卡型号。</p><p>从Nvidia官网下载相应驱动：<a target="_blank" rel="noopener" href="https://www.nvidia.com/Download/index.aspx">https://www.nvidia.com/Download/index.aspx</a></p><h1 id="关闭图形界面"><a href="#关闭图形界面" class="headerlink" title="关闭图形界面"></a>关闭图形界面</h1><p>Ubuntu18.04已经与之前的版本不一样了，比较麻烦。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Ubuntu18.04</span><br><span class="line">    #关闭图形界面</span><br><span class="line">$ sudo systemctl set-default multi-user.target</span><br><span class="line">$ sudo reboot</span><br><span class="line">    #开启图形界面</span><br><span class="line">$ sudo systemctl set-default graphical.target</span><br><span class="line">$ sudo reboot</span><br><span class="line"></span><br><span class="line"># Ubuntu16.04</span><br><span class="line">sudo service lightdm stop</span><br><span class="line">sudo service lightdm start</span><br></pre></td></tr></table></figure><h1 id="禁用nouveau"><a href="#禁用nouveau" class="headerlink" title="禁用nouveau"></a>禁用nouveau</h1><p>Ubuntu 系统默认安装好是使用的一个开源的驱动： <code>nouveau</code>，我们要安装官方的驱动需要先禁用这个开源驱动，方法如下，依次执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c <span class="string">&quot;echo blacklist nouveau &gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf&quot;</span></span><br><span class="line">sudo bash -c <span class="string">&quot;echo options nouveau modeset=0 &gt;&gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf&quot;</span></span><br></pre></td></tr></table></figure><p>查看是否禁用成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/modprobe.d/blacklist-nvidia-nouveau.conf</span><br><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0           <span class="comment"># 表示成功</span></span><br><span class="line"></span><br><span class="line">$ sudo update-initramfs -u  <span class="comment"># 重新加载驱动</span></span><br><span class="line"></span><br><span class="line">$ sudo reboot   <span class="comment">##重启生效</span></span><br><span class="line"></span><br><span class="line">$ lsmod | grep nouveau   <span class="comment"># 无任何输出即表示成功</span></span><br></pre></td></tr></table></figure><h1 id="安装Nvidia驱动"><a href="#安装Nvidia驱动" class="headerlink" title="安装Nvidia驱动"></a>安装Nvidia驱动</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">$ sudo apt install gcc g++ make dkms</span><br><span class="line"><span class="comment">#提升驱动安装脚本的执行权限</span></span><br><span class="line">$ sudo <span class="built_in">chmod</span> +x NVIDIA-Linux-x86_64-384.98.run <span class="comment">#根据下载好的版本输入</span></span><br><span class="line">$ sudo ./NVIDIA-Linux-x86_64-384.98.run</span><br><span class="line"><span class="comment"># 按照提示选择安装即可</span></span><br><span class="line"><span class="comment"># 安装完成后测试是否安装成功</span></span><br><span class="line">$ nvidia-smi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下即表示安装成功</span></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 384.98                 Driver Version: 384.98                    |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  GeForce GT 635M     Off  | 00000000:01:00.0 N/A |                  N/A |</span><br><span class="line">| N/A   47C    P0    N/A /  N/A |      0MiB /  1985MiB |     N/A      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">                                                                               </span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                       GPU Memory |</span><br><span class="line">|  GPU       PID   Type   Process name                             Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|    0                    Not Supported                                       |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
